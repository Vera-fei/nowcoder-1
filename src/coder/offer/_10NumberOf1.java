package coder.offer;
//@formatter:off
/**
 *                             _ooOoo_
 *                            o8888888o
 *                            88" . "88
 *                            (| -_- |)
 *                            O\  =  /O
 *                         ____/`---'\____
 *                       .'  \\|     |//  `.
 *                      /  \\|||  :  |||//  \
 *                     /  _||||| -:- |||||-  \
 *                     |   | \\\  -  /// |   |
 *                     | \_|  ''\---/''  |   |
 *                     \  .-\__  `-`  ___/-. /
 *                   ___`. .'  /--.--\  `. . __
 *                ."" '<  `.___\_<|>_/___.'  >'"".
 *               | | :  `- \`.;`\ _ /`;.`/ - ` : | |
 *               \  \ `-.   \_ __\ /__ _/   .-` /  /
 *          ======`-.____`-.___\_____/___.-`____.-'======
 *                             `=---='
 *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *                     佛祖保佑        永无BUG
 *
 * 描述：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 */
 //@formatter:on
public class _10NumberOf1 {
    //此法不行，当传入一个负数时，因为右移时，最高位设为1，如果一直做右移运算，最终这个数字变成0xFFFFFFFF而陷入死循环 二进制表示为11111111 11111111 11111111 11111111 其十进制为-1（负数用补码表示：1的反码+1）
    public int NumberOf1_1(int n) {
        int count = 0;
        while (n != 0) {
            if ((n & 1) == 1) count++;
            n = n >> 1;
        }
        return count;
    }

    //用1先按位与，然后不断左移，进行按位与操作
    public int NumberOf1_2(int n) {
        int count = 0;
        int flag = 1;//00000000 00000000 00000000 00000001
        while (flag != 0) {//flag一直左移（int占了四个字节即32位），当最左边1超出边界，则flag = 0
            if ((n & flag) != 0) count++;
            flag = flag << 1;
        }
        return count;
    }

    //最好的方法
    //把一个整数和它减去1的结果做位与运算，相当于把该数最右边的1变成0
    public int NumberOf1_3(int n) {
        int count = 0;
        while (n != 0) {
            count++;
            n = n & (n - 1);
        }
        return count;
    }
}
